1. 정보보안

    *. 정보를 수집, 가공, 저장, 전송 등 과정에서 정보의 훼손, 변조, 위조, 유출 등 방지하기 위해 관리적, 물리적, 기술적으로 정보를 보호하는 것을 말한다.
    *. 기밀성, 무결성, 가용성을 보장하는 것이 정보보안의 목표다.

        *. 기밀성이란, 정보를 인가된 사용자에게만 노출되도록 하는 것이다.
        *. 무결성이란, 정보를 송수신하는 과정에서 원본이 유지되는 것이 보장하는 것이다.
        *. 가용성이란, 인가된 사용자가 정보를 원할 때 사용할 수 있음을 보장하는 것이다.

    *. 인증 (Authentication)
    *. 정보의 주체가 되는 송신자와 수신자 간에 교류되는 정보의 내용이 변조 또는 삭제되지 않았는지, 그리고 주체가 되는 송수신자가 정당한지 확인하는 방법이다.
    *. 부인방지 (non-repudiation)
    *. 메세지를 송수신한 후 송수신 사실을 증명함으로써 송수신 여부에 대한 부인을 방지하기 위한 기술을 말한다.

        *. non-repudiation of origin (송신부인방지): 송신자의 송신 부인을 방지.
        *. non-repudiation of delivery (전달부인방지): 수신자의 전달 부인을 방지.
        *. non-repudiation of receipt (수신부인방지): 수신자의 수신 부인을 방지.

    *. 암호기술
    *. 암호기술은 암호화 기술, 암호 프로토콜 기술로 분류한다.

        *. 암호화 기술
        *. 암호화 키, 복호화 키가 같은지 여부에 따라 대칭키, 공개키 암호 방식으로 분류한다.
        *. 대칭키는 암호화 키와 복호화 키가 동일하다.
        *. 공개키는 암호화 키와 복호화 키가 다르다.

        *. 암호 프로토콜 기술
        *. 암호 기술을 사용하는 프로토콜을 말한다.
        *. 프로토콜은 목적을 달성하기 위해 두 명 이상의 참여자가 거치는 유한한 일련의 단계를 의미한다.
        *. 암호 프로토콜은 각 메세지의 의미를 보장한다.
        *. 또한 인증, 기밀성, 무결성, 부인방지 등 기능을 보장하기 위해 참여자 혹은 제3자가 부정을 못하도록 해야 한다.

    *. 전자 서명 (Digital Signature)
    *. 특정 문서에 자신의 개인키를 이용해 해쉬 연산을 하여 데이터의 무결성과 서명자의 인증성을 함께 제공하는 방식이다.
    *. 메세지 전체에 대해 직접 서명하는 것은 공개키 연산을 모든 메세지 블록마다 반복해야 하기 때문에 매우 비효율적이다.
    *. 따라서 메세지에 대한 해쉬 값을 계산한 후 이것에 대해 서명함으로써 효율적으로 전자서명을 생성할 수 있다.
    *. 서명자는 메세지 자체가 아니라 메세지의 해쉬 값에 대해 서명을 했지만 같은 값을 가지는 다른 메세지를 찾아내기 어렵기 때문에 이 서명은 메세지에 대한 서명으로 인정된다.

    *. 해쉬 함수 (Hash Function)
    *. 해쉬 함수 또는 해쉬 알고리즘은 다양한 크기의 임의의 문자열을 고정된 길이의 짧은 해쉬 값으로 (Hash Code) 변환하여 출력하는 수학적 함수다.
    *. 즉, 임의의 길이를 가지는 입력 비트열을 고정된 짧은 길이로 함축하는 기능이다.
    *. 암호 알고리즘에는 키가 사용되지만, 해쉬 함수는 키를 사용하지 않는다.
    *. 따라서 같은 입력에는 항상 같은 출력을 가진다.
    *. 이런 해쉬 함수의 특성을 이용해 입력 메세지에 대한 오류, 변조를 탐지할 수 있는 무결성 검증에 이용한다.

    *. 악성 코드
    *. 악성 소프트웨어의 줄임말 (malicious software)
    *. 파일 시스템 또는 네트워크에 대해 악성 행위를 하도록 설계된 소프트웨어다.

        *. Worm: 독립적으로 실행되며, 스스로 복제하고 다른 컴퓨터로 확산된다.
        *. Virus: 다른 독립적 프로그램의 코드 내부에 삽입되어 해당 프로그램이 악성 행동을 하고 스스로 확산되도록 하는 악성 코드다.
        *. Trojan Horse: 정상적인 프로그램처럼 보이나 사용자가 실행하면 숨겨진 악성 코드가 실행된다.

    *. 주요 보안 솔루션

        *. FireWall (방화벽): 사설 네트워크를 외부로부터 보호하기 위해 공중 네트워크와 사설 네트워크 사이에 설치하는 보안 솔루션이다. 두 가지 형태가 있는데, Packet Filtering Gateway는 일련의 규칙을 설정해 패킷의 통과 여부를 판단하는 장치다. Proxy Server는 사설 네트워크로 접속하기 위해 특정 호스트에게 인증을 제공하고 패킷을 전달하는 것을 허용하는 시스템을 지칭한다. 이 외에도 두 가지 방식을 혼용해 보안성을 높인 방법도 사용하고 있다.
        *. IPS, Intrusion Protection System (침입 방지 시스템): 네트워크 탐지 영역에 대한 (대상 시스템) 인가되지 않은 행위와 비정상적인 행동을 탐지하고, 탐지된 불법 행위를 구별하여 실시간으로 침입을 차단하는 기능을 가진 보안 시스템이다. 침입자 행위의 평균 영역과 인가자 행위의 평균 영역 간에 존재하는 공통 영역이 침입 탐지를 어렵게 하는 요인임을 짐작할 수 있다. 침입 탐지 시스템은 일반적인 보안 시스템 구현 절차의 관점에서 방화벽과 더불어 가장 우선적으로 구축되며, 구축 목적은 해킹 등 불법 행위에 대한 실시간 탐지 및 차단과 방화벽에서 허용한 패킷을 이용하여 행해지는 공격에 대한 방어 등 목적으로 구축된다.
        *. VPN, Virtual Private Network (가상 사설망): 원격지 간에 Private Network를 물리적으로 구축하지 않고 인터넷 같은 공중망(Public Network)을 사설망처럼 접근통제, 인증, 기밀성 서비스를 이용할 수 있도록 하는 기술이다. IPSec, SSL 같은 기술로 구현하며, 전송 시스템, 라우터, 방화벽에 구현하는 방법이 있다.
        *. SSO, Single Sign On (통합인증): 하나의 사이트에 로그인하면 다른 사이트에 별도의 인증절차 없이 인증할 수 있도록 한다. 일반적으로 서로 다른 사이트 및 시스템에서는 사용자 정보를 별도로 관리하나, 필요에 따라서 사용자 정보를 연동하여 사용할 필요가 존재한다. 이 때, SSO를 이용하여 하나의 사용자 정보를 기반으로 여러 시스템을 하나의 통합 인증을 사용하도록 할 수 있다.
        *. WAF, Web Application Firewall (웹방화벽): 웹서버의 앞쪽에 위치하여 외부로부터 들어오는 HTTP/HTTPS 프로토콜에 대한 트래픽을 감시하며, SQL Injection 공격이나 XSS 공격 같은 웹앱에 대한 악의적인 공격이 탐지되면 해당 공격이 웹 서버에 도달하기 전에 차단하는 역할을 수행하는 보안 솔루션이다.
        *. SQL Injection: 클라이언트의 입력값을 조작하여 서버의 데이터베이스를 공격하는 방법이다. 필터링, 이스케이핑이 제대로 되지 않았다면 발생하나, 너무나 잘 알려진 공격방법이므로 대부분의 서버는 SQL Injection에 대한 방어가 준비되어 있다.
        *. XSS, Cross Site Scripting: 공격자가 상대방의 브라우저에 스크립트가 실행되도록 해 사용자의 세션을 가로채거나, 웹사이트를 변조하거나, 악의적인 컨텐츠를 삽입하거나, 피싱 공격을 진행하는 것을 말한다. 해커는 웹사이트에 악성 스크립트를 주입하고, 해당 스크립트가 포함된 게시글을 읽은 피해자의 쿠키는 해커에게 전송된다. 해당 쿠키를 바탕으로 해커는 피해자의 브라우저에서 악의적인 행동을 할 수 있다. 주요 목표는 사용자의 정보를 취득하는 것. 주로 로그인 입력란을 감염시켜 버튼을 클릭시 입력정보가 담긴 쿠키를 해커에게 전송한다.
        *. Session: 웹 사이트의 여러 페이지에 걸쳐 사용되는 사용자 정보를 저장하는 방법을 의미한다. 사용자가 브라우저를 닫아 서버와의 연결을 끝내는 시점까지 세션이라고 함.
            *. Login (Client, C)
            *. Session created. Return session ID. (Server, S)
            *. Browser sends session ID for all subsequent requests. (C)
            *. Send request with session ID. (C)
            *. Return response for given session ID. (S)

            *. 사용자가 로그인한다.
            *. 서버는 Session ID를 만들고, 사용자에게 전송하여, 브라우저 쿠키에 저장한다.
            *. 사용자가 웹페이지의 특정 요청을 하게 되면, Session ID가 담긴 쿠키를 헤더에 담아 전송한다.
            *. 전달받은 서버는 Session ID를 기반으로 Session에 담긴 정보를 가져온다.
            *. 해당 정보로 서버 요청을 처리하여 클라이언트에 응답한다.

            *. 각 클라이언트가 요청을 보내면 고유한 Session ID를 부여하여 응답한다.
            *. 사용자가 처음 접속부터 브라우저를 종료할 때까지 인증 상태를 유지한다.
            *. 접속 시간에 제한을 두어, 일정시간 응답이 없으면 인증 상태를 종료할 수 있다.
            *. 트래픽이 많을수록, 동시 접속자가 많을수록, 서버의 메모리를 많이 차지한다.
            *. 서버에서 관리하기 때문에 쿠키보다 보안 면에서 우수하다.

            *. 세션은 서버의 자원을 이용한다.
            *. 서버의 자원을 이용하기 때문에 트래픽이 많으면 퍼포먼스가 떨어진다.
            *. 만료시간을 설정할 수 있으나, 브라우저가 종료되면 즉시 삭제된다.
            *. 쿠키는 Request에서 탈취당할 수 있으나, 세션은 쿠키에 Session ID만 저장하고 서버에서 처리하기 때문에 보안상 더 우수하다. 
            *. 쿠키는 자동 로그인 설정, 팝업 하루 보이지 않기 등 민감하지 않은 정보만 담는다.
            *. 세션은 민감한 개인정보를 담아두며, 서버 퍼포먼스를 관리하기 위해서 세션 관리 서버를 별도로 만들어서 관리한다.