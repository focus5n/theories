*. 목표

    *. 암호와 인증기술 및 접근통제 이해하기
    *. 기밀성 지원을 위한 암호의 개념과 고전암호에 대해 설명할 수 있다.
    *. 비밀키 암호화와 공개키 암호화 알고리즘을 설명할 수 있다.
    *. 무결성 지원을 위한 해쉬함수에 대해 설명할 수 있다.
    *. 안전한 거래를 위한 전자서명과 PKI(Public Key Infrastructure)를 설명할 수 있다.
    *. 접근통제를 위한 인증기술과 인증방법을 설명할 수 있다.

    *. 암호 알고리즘
    *. 비밀키 암호화
    *. 공개키 암호화
    *. 해쉬 함수
    *. 인증
    *. 전자 서명
    *. PKI
    *. 접근통제
    *. 암호 프로토콜
    *. DES
    *. AES
    *. RSA
    *. ECC
    *. 해쉬 충돌
    *. 공인인증서
    *. Multi Factor 인증
    *. Session Key

*. 암호 기술

    *. 평문(PlainText)을 해석하기 불가능한 암호문(CipherText)로 변형하는 기술.
    *. 암호화(Encryption)
    *. 복호화(Decryption)
    *. 이 개념을 합쳐 암호학(Cryptography)이라 부른다.

    *. 두 변환 과정에서 사용하는 수학적 기능을 암호 알고리즘이라 한다.
    *. 암호 알고리즘은 암호화와 복호화를 수행하기 위해 KEY를 사용한다.
    *. 즉, 정보보안 3대 목표 중 하나인 기밀성을 얻기 위한 수단이 암호화다.

*. 암호화 및 복호화

    *. 암호화는 평문을 인가받지 않은 제3자가 인식할 수 없는 암호문으로 변환하는 과정이다.
    *. 복호화는 암호문을 평문으로 복원하는 과정이다.
    *. 각 과정에는 암호화 키, 복호화 키를 암호 알고리즘에 대입하는 과정이 삽입된다.

*. 암호 기술 분류

    *. 암호화 기술: 암호화 키와 복호화 키가 같은 대칭키, 서로 다른 공개키 방식이 존재한다.
    *. 프로토콜: 목적 달성을 위해 두 명 이상이 참여하는 유한한 일련의 단계.
    *. 암호 프로토콜: 프로토콜의 각 메세지의 의미를 보장하며, 부정을 방지한다.

    *. 대칭키 암호 알고리즘
        *. 블록 암호 방식
        *. 스트림 암호 방식
    *. 공개키 암호 알고리즘
        *. 인수분해 문제
        *. 이산대수 문제
        *. 타원곡선 문제
    *. 기본 암호 프로토콜
        *. 개인 식별 및 개인 인증
        *. 전자서명
    *. 암호 프로토콜
        *. 전자결제
        *. 전자화폐
        *. 전자선거

    *. 암호 시스템
        *. 암호화하고 복호화하는 일련의 과정에 필요한 요소들을 합쳐 암호 시스템이라 한다.
        *. 암호 키에 의한 보안이 이루어져야 한다.

    *. 비밀키 암호 알고리즘
        *. 암호화와 복호화에 사용하는 키가 동일.
        *. 키의 길이가 짧아도 되고 암호화 및 복호화 연산의 속도가 빠르다.
        *. 키를 비밀리에 보관하고 관리한다는 측면에서 비밀키라고 부름.
        *. 통상적으로 사용한다는 의미에서 관용 암호 방식이라고 함.

        *. 블록 암호화
            *. 평문을 블록이라고 부르는 고정 길이의 입력으로 나누어 블록 단위로 암호화 수행
            *. 오류 확산의 위험
            *. 초기값 설정 필요
            *. 구현 용이
            *. DES, AES, IDEA, SEED, ARIA, Feistel Network
        *. 스트림 암호화
            *. 평문을 비트 단위로 암호화 수행
            *. 느림
            *. 악의적 공격자에 의해 내용 변경이 용이
            *. 오류 확산의 위험이 낮음
            *. 이동통신 환경에서 구현 용이

    *. 공개키 암호 알고리즘
        *. 다른 사용자와 키를 공유하지 않아도 된다.
        *. 자신에게 송신하기 위해 사용할 키 (공개키)
        *. 자신의 공개키로 암호화된 정보를 복호화할 수 있는 키 (개인키)
        *. 누구나 암호화가 가능하지만, 복호화는 개인키를 가진 당사자만 가능하다.
        *. RSA, ElGamal, ECC

    *. 해쉬 함수
        *. 다양한 크기를 가지는 임의의 데이터를 고정된 길이의 짧은 해쉬 코드로 출력.
        *. SHA-1은 160비트의 결과를 출력한다.
        *. 해쉬 함수는 암호 알고리즘과 다르게 키를 사용하지 않는다.
        *. 같은 입력에 대해서 같은 출력이 나온다. 
        *. 입력 메세지에 대한 변경할 수 없는 증거값 추출 가능.
        *. 무결성 검증에 이용.
        
        *. 해쉬 값을 이용해 원래의 문장을 계산적으로 복원할 수 없다.
        *. 해쉬 충돌을 이용한 우회적 공격은 가능하다.

        *. MD5, 지금은 사용 안함.
        *. SHA, Secure Hash Algorithm: SHA1 ~ SHA3

        *. Salt: 해쉬 값을 생성할 때 추가되는 임의의 비트열이다.
        *. bit열: bit string. bit array.
        *. Salting: 패스워드 + Salt. Salt의 길이는 최소 32비트는 되어야 솔트와 다이제스트를 유추하기 어렵다고 한다.
        *. Digest: Hash Function을 통과하기 이전의 원본 데이터를 message라고 부르며 통과된 이후의 데이터를 Digest라 부른다.

    *. 주기적 검사 vs 실시간 탐지

        *. 주기적 검사는 검사 주기 사이에 발생한 보안사고를 찾아낼 수 없다.
        *. 검사 주기가 짧으면 파일의 개수가 많아지며 서버의 부담이 증가한다.
        
        *. 실시간 탐지는 주기적 검사를 대체할 수 있다.
        *. 무결성 검사는 최초 1회만 수행하며 해당 파일이 실행되거나 메모리에 적재될 때마다 검사하여 실시간으로 파일 변조 여부를 검사한다.
        *. 지속적인 CPU 부하를 방지할 수 있다.

    *. 전송 과정에서의 무결성
    
        *. 송신자는 메시지에 대한 해쉬 값을 메시지와 함께 전송.
        *. 수신자는 메시지의 무결성 검사를 진행하고 변조됐다면 메시지를 무시.
        
        *. 송신자 신분에 대한 인증이 필요없다면, MAC (Message Authentication Code) 메시지 인증 코드라는 형태로 해쉬 함수를 사용.
        *. 송신자가 메시지를 입력하여 해쉬 값을 계산하면 MAC이 된다.
        *. 메시지와 함께 이 메시지인증코드를 보내면 수신자는 메시지가 변조되지 않았다고 확신할 수 있다.

    *. 인증, Authentication
    
        *. 사용자 인증
            *. 사용자가 자신이 진정한 사용자임을 상대방에게 증명하는 기능
            *. 제3자가 사용자 행세를 하는 것이 불가능해야 한다.
            *. 사용자 인증 = 신원 확인 (Identification)
            *. 서버에 로그인할 때 사용자의 신분을 확인하고 정보서비스를 이용할 수 있는 권한을 부여할 때 사용한다.

        *. 메시지 인증
            *. 전송되는 메시지의 내용이 변경이나 수정되지 않았음을 확인하는 기능.
            *. 누가 보냈고, 변조되지 않았다는 것을, 전자서명을 통해 증명할 수 있다.

        *. OTP (One Time Password)