# 디자인 패턴

## 개념

    - 전형적인 문제해결 방식

## 구성요소

    1. 패턴 이름: 패턴 이름
    2. 문제 및 배경: 패턴 적용 범위
    3. 솔루션: 패턴 요소, 관계, 협동 과정
    4. 사례: 패턴 적용 사례
    5. 결과: 패턴 적용 이점
    6. 샘플 코드: 패턴 적용 원시 코드

## 유형

    1. 목적
        1. 생성: 객체 생성 방식
        2. 구조: 객체 조합 방식
        3. 행위: 객체 역할 분담

    2. 범위
       1. 클래스: 컴파일 시점에, 정적으로 결정
       2. 객체: 런타임 시점에, 동적으로 결정

## 종류

    1. 생성 패턴
        1. Builder: 객체 생성을 객체 구현에서 분리
        2. Prototype: 객체 원형을 생성한 뒤 복사하여 필요한 부분만 수정하여 사용
        3. Factory Method: 상위 클래스에서 객체 생성 인터페이스 정의. 하위 클래스에서 객체 구현 클래스 정의.
        4. Abstract Factory: 여러 인터페이스에 기능을 명시하고, 인터페이스를 조합하여 구현한 클래스를 API로 제공.
        5. SingleTon: 전역 변수 대신 전역 객체를 단 하나만 생성하여 사용.

    2. 구조 패턴
       1. Bridge
          1. 인터페이스에 기능을 명시하고, 기능 클래스가 해당 인터페이스를 구현.
          2. 인터페이스를 최상위 구현 클래스가 구현. 최상위 구현 클래스를 상속받은 여러 구현 클래스를 생성.
       2. Decorator
          1. Tree 구조로 부모 클래스의 요소를 자식 클래스에서 표현
       3. Facade
          1. 다양한 클래스를 연결하는 정면 클래스를 생성
          2. 정면 클래스에서는 간단하게 메서드만 사용하여 구현 (코드를 볼 필요가 없다)
       4. FlyWeight
          1. 여러 객체에서 사용하는 상태 정보를 단 하나의 객체에서 공유
       5. Proxy
          1. 객체에 접근하기 이전에 필요한 행위를 처리하는 객체를 생성
          2. 접근에 필요한 행위를 모두 처리하면 필요한 객체를 생성
          3. 필요한 객체를 노출하지 않으므로 정보은닉에 도움이 됨


    3. 행위 패턴