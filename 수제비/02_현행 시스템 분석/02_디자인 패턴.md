# 디자인 패턴

## 개념

    - 전형적인 문제해결 방식

## 구성요소

    1. 패턴 이름: 패턴 이름
    2. 문제 및 배경: 패턴 적용 범위
    3. 솔루션: 패턴 요소, 관계, 협동 과정
    4. 사례: 패턴 적용 사례
    5. 결과: 패턴 적용 이점
    6. 샘플 코드: 패턴 적용 원시 코드

## 유형

    1. 목적
        1. 생성: 객체 생성 방식
        2. 구조: 객체 조합 방식
        3. 행위: 객체 역할 분담

    2. 범위
       1. 클래스: 컴파일 시점에, 정적으로 결정
       2. 객체: 런타임 시점에, 동적으로 결정

## 종류

    1. 생성 패턴
        1. Builder: 객체 생성을 객체 구현에서 분리
        2. Prototype: 객체 원형을 생성한 뒤 복사하여 필요한 부분만 수정하여 사용
        3. Factory Method: 상위 클래스에서 객체 생성 인터페이스 정의. 하위 클래스에서 객체 구현 클래스 정의.
        4. Abstract Factory: 여러 인터페이스에 기능을 명시하고, 인터페이스를 조합하여 구현한 클래스를 API로 제공.
        5. SingleTon: 전역 변수 대신 전역 객체를 단 하나만 생성하여 사용.

    2. 구조 패턴
       1. Bridge
          1. 인터페이스에 기능을 명시하고, 기능 클래스가 해당 인터페이스를 구현.
          2. 인터페이스를 최상위 구현 클래스가 구현. 최상위 구현 클래스를 상속받은 여러 구현 클래스를 생성.
       2. Decorator
          1. Tree 구조로 부모 클래스의 요소를 자식 클래스에서 표현
       3. Facade
          1. 다양한 클래스를 연결하는 정면 클래스를 생성
          2. 정면 클래스에서는 간단하게 메서드만 사용하여 구현 (코드를 볼 필요가 없다)
       4. FlyWeight
          1. 여러 객체에서 사용하는 상태 정보를 단 하나의 객체에서 공유
       5. Proxy
          1. 객체에 접근하기 이전에 필요한 행위를 처리하는 객체를 생성
          2. 접근에 필요한 행위를 모두 처리하면 필요한 객체를 생성
          3. 필요한 객체를 노출하지 않으므로 정보은닉에 도움이 됨
       6. Composite
          1. 객체 관계를 트리 구조로 구성
          2. 복합 객체와 단일 객체를 동일하게 다룸
          3. Compnent - Leaf, Composite - Leaf
       7. Adapter
          1. 기존 클래스를 재사용하기 위하여 중간에서 패턴을 동일하게 맞춰주는 인터페이스를 생성

    3. 행위 패턴
       1. Mediator
          1. 느슨한 결합을 유지하기 위함
          2. 객체 간 통신이 아니라 모든 통신을 중재자가 수용
       2. Interpreter
          1. client, context, abstractExpression을 나눔
          2. context는 interpreter에게 전달하는 string 정보
          3. client는 interpret() 메서드를 호출
          4. abstractExpression은 interpret()을 정의
          5. TerminalExpression에서 interpret()을 구현
       3. Iterator
          1. 컬렉션 구현 방법을 노출하지 않음
          2. 집합체 안의 모든 항목에 접근할 방법을 제공
          3. 복잡한 객체의 원소를 순차적으로 접근하게 함
       4. Template Method
          1. 상위 클래스에서 추상 메서드를 통해 기능의 골격을 제공
          2. 하위 클래스의 메서드에서 세부 처리를 구체화함
       5. Observer
          1. 한 객체의 상태가 변화하면 의존하는 다른 객체들에게 연락이 감
          2. 자동으로 내용이 갱신
       6. State
          1. 객체의 상태를 하나의 클래스로 만듬
          2. 해당 클래스를 참조하여 행위 내용을 변경할 수 있도록 함
       7. Visitor
          1. 객체의 데이터 구조와 처리 기능을 분리
          2. 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업만 수행
          3. 객체 구조를 변경하지 않고 기능만 추가할 때 사용
       8. Command
          1. 요구사항을 객체로 캡슐화
       9. Strategy
          1. 알고리즘 군을 추상 클래스로 정의
          2. 알고리즘을 각각 클래스로 캡슐화
       10. Memento
           1. Undo 기능을 구현할 때 사용
       11. Chain of Responsibility
           1. 하드코딩된 기능을 다른 객체에서 받아서 처리하여 다르게 처리